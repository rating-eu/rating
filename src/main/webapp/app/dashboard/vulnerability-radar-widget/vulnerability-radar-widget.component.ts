import {ChangeDetectorRef, Component, OnDestroy, OnInit, ViewRef} from '@angular/core';
import {ChartDataSets, ChartType, RadialChartOptions} from 'chart.js';
import {DataSharingService} from '../../data-sharing/data-sharing.service';
import {Subscription} from 'rxjs';
import {QuestionnaireStatusMgm} from '../../entities/questionnaire-status-mgm';
import {VulnerabilityAreaMgm, VulnerabilityAreaMgmService} from '../../entities/vulnerability-area-mgm';
import {HttpResponse} from '@angular/common/http';
import {MatSlideToggleChange} from "@angular/material";


@Component({
    selector: 'jhi-vulnerability-radar-widget',
    templateUrl: './vulnerability-radar-widget.component.html',
    styles: []
})
export class VulnerabilityRadarWidgetComponent implements OnInit, OnDestroy {

    private subscriptions: Subscription[];
    public isCollapsed = true;
    public vulnerabilityAssessment: QuestionnaireStatusMgm;
    public vulnerabilityAreas: VulnerabilityAreaMgm[];
    public vulnerabilityAreasToggleMap: Map<number/*AreaID*/, boolean>;

    // Chart
    public radarChartLabels: String[] = ['Human', 'IT', 'Physical'];
    public radarChartType: ChartType = 'radar';

    // Data
    private dataSetByAreaMap: Map<number/*AreaID*/, ChartDataSets>;

    public radarChartData: ChartDataSets[];

    constructor(
        private dataSharingService: DataSharingService,
        private vulnerabilityAreaService: VulnerabilityAreaMgmService,
        private changeDetector: ChangeDetectorRef) {
    }

    ngOnInit() {
        this.subscriptions = [];
        this.vulnerabilityAreas = [];
        this.vulnerabilityAreasToggleMap = new Map();
        this.dataSetByAreaMap = new Map();
        this.radarChartData = [];

        this.vulnerabilityAssessment = this.dataSharingService.vulnerabilityAssessment;

        this.subscriptions.push(
            this.dataSharingService.vulnerabilityAssessment$.subscribe(
                (assessment: QuestionnaireStatusMgm) => {
                    this.vulnerabilityAssessment = assessment;
                }
            )
        );

        this.vulnerabilityAreaService.query().toPromise().then((response: HttpResponse<VulnerabilityAreaMgm[]>) => {

            if (response.body) {
                this.vulnerabilityAreas = response.body;

                this.vulnerabilityAreas.forEach((area: VulnerabilityAreaMgm) => {
                    this.vulnerabilityAreasToggleMap.set(area.id, true);
                });

                // Build the DataSets
                this.vulnerabilityAreas.forEach((area: VulnerabilityAreaMgm) => {
                    const human: number = Math.floor(Math.random() * 3 + 2);
                    const it: number = Math.floor(Math.random() * 3 + 2);
                    const physical: number = Math.floor(Math.random() * 3 + 2);

                    this.dataSetByAreaMap.set(area.id, {data: [human, it, physical], label: area.name});

                    this.radarChartData.push(this.dataSetByAreaMap.get(area.id));
                });

                if (this.changeDetector && !(this.changeDetector as ViewRef).destroyed) {
                    this.changeDetector.detectChanges();
                }
            }
        });
    }

    // Radar
    public radarChartOptions: RadialChartOptions = {
        responsive: true,
        scale: {
            ticks: {
                beginAtZero: true,
                min: 0,
                max: 5
            }
        }
    };

    public toggleChange(area: VulnerabilityAreaMgm, change: MatSlideToggleChange) {
        console.log("Toggle Change...");

        this.vulnerabilityAreasToggleMap.set(area.id, change.checked);

        // Update the DataSet
        this.radarChartData = [];

        if (this.changeDetector && !(this.changeDetector as ViewRef).destroyed) {
            this.changeDetector.detectChanges();
        }

        this.dataSetByAreaMap.forEach((value: ChartDataSets, key: number /*AreaID*/) => {
            if (this.vulnerabilityAreasToggleMap.get(key)) {
                this.radarChartData.push(value);
            }
        });

        if (this.changeDetector && !(this.changeDetector as ViewRef).destroyed) {
            this.changeDetector.detectChanges();
        }
    }

    ngOnDestroy(): void {
        this.changeDetector.detach();

        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((subscription: Subscription) => {
                if (subscription) {
                    subscription.unsubscribe();
                }
            });
        }
    }
}
