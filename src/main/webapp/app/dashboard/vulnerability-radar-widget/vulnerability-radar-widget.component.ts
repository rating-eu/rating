import {ChangeDetectorRef, Component, OnDestroy, OnInit, ViewRef} from '@angular/core';
import {ChartDataSets, ChartType, RadialChartOptions} from 'chart.js';
import {DataSharingService} from '../../data-sharing/data-sharing.service';
import {Subscription} from 'rxjs';
import {QuestionnaireStatusMgm} from '../../entities/questionnaire-status-mgm';
import {VulnerabilityAreaMgm, VulnerabilityAreaMgmService} from '../../entities/vulnerability-area-mgm';
import {HttpResponse} from '@angular/common/http';
import {VulnerabilityRadarService} from "./vulnerability-radar.service";
import {ContainerType} from "../../entities/enumerations/ContainerType.enum";

@Component({
    selector: 'jhi-vulnerability-radar-widget',
    templateUrl: './vulnerability-radar-widget.component.html',
    styleUrls: ['vulnerability-radar.css']
})
export class VulnerabilityRadarWidgetComponent implements OnInit, OnDestroy {

    // Low Countermeasure Vulnerability
    public readonly LCV = 5;

    private subscriptions: Subscription[];
    public isCollapsed = true;
    public vulnerabilityAssessment: QuestionnaireStatusMgm;
    public vulnerabilityAreas: VulnerabilityAreaMgm[];
    public vulnerabilityAreasMap: Map<number, VulnerabilityAreaMgm>;
    public vulnerabilityAreasToggleMap: Map<number/*AreaID*/, boolean>;

    public containerTypes: ContainerType[];
    public containerTypeEnum = ContainerType;

    // Radar
    public overallRadarChartOptions: RadialChartOptions = {
        legend: {
            position: "bottom"
        },
        responsive: true,
        maintainAspectRatio: false,
        scale: {
            ticks: {
                beginAtZero: false,
                min: 1,
                max: 5
            }
        }
    };

    public radarChartOptions: RadialChartOptions = {
        legend: {
            position: "bottom"
        },
        responsive: true,
        maintainAspectRatio: false,
        scale: {
            ticks: {
                beginAtZero: false,
                min: 1,
                max: 5
            }
        }
    };

    // Chart
    public radarChartLabels: String[] = ['Human', 'IT', 'Physical'];
    public radarChartType: ChartType = 'radar';

    // Data
    public data: Map<number/*AreaID*/, Map<ContainerType, number/*Vulnerability*/>>;
    private dataSetByAreaMap: Map<number/*AreaID*/, ChartDataSets>;

    public overallRadarChartDataSets: ChartDataSets[];
    public radarChartDataSets: ChartDataSets[];

    constructor(
        private dataSharingService: DataSharingService,
        private vulnerabilityAreaService: VulnerabilityAreaMgmService,
        private vulnerabilityRadarService: VulnerabilityRadarService,
        private changeDetector: ChangeDetectorRef) {
    }

    ngOnInit() {
        this.subscriptions = [];
        this.vulnerabilityAreas = [];
        this.vulnerabilityAreasMap = new Map();
        this.vulnerabilityAreasToggleMap = new Map();
        this.dataSetByAreaMap = new Map();

        this.overallRadarChartDataSets = [];
        this.radarChartDataSets = [];

        this.containerTypes = Object.keys(ContainerType).map((key) => ContainerType[key]);
        // Remove the last one (Intangible)
        this.containerTypes = this.containerTypes.slice(0, this.containerTypes.length - 1);

        this.vulnerabilityAssessment = this.dataSharingService.vulnerabilityAssessment;
        this.fetchDataSet();

        this.subscriptions.push(
            this.dataSharingService.vulnerabilityAssessment$.subscribe(
                (assessment: QuestionnaireStatusMgm) => {
                    this.vulnerabilityAssessment = assessment;
                    this.fetchDataSet();
                }
            )
        );

        this.vulnerabilityAreaService.query().toPromise().then((response: HttpResponse<VulnerabilityAreaMgm[]>) => {

            if (response.body) {
                this.vulnerabilityAreas = response.body;

                this.vulnerabilityAreas.forEach((area: VulnerabilityAreaMgm) => {
                    this.vulnerabilityAreasMap.set(area.id, area);
                    this.vulnerabilityAreasToggleMap.set(area.id, true);
                });

                if (this.changeDetector && !(this.changeDetector as ViewRef).destroyed) {
                    this.changeDetector.detectChanges();
                }
            }
        });
    }

    private buildDataSet() {
        // Build the DataSets
        if (this.data && this.vulnerabilityAreas && this.vulnerabilityAreasMap) {
            this.data.forEach((value: Map<ContainerType, number/*Vulnerability*/>, key: number /*AreaID*/) => {
                let human: number = Number(value.get(ContainerType.HUMAN).toPrecision(2));
                let it: number = Number(value.get(ContainerType.IT).toPrecision(2));
                let physical: number = Number(value.get(ContainerType.PHYSICAL).toPrecision(2));

                if (key === -1) { // Overall Vulnerabilities
                    // Attention: multiply values by 5 (Vulnerability of a LOW Countermeasure) cause it's a percentage
                    human = Number((human * this.LCV).toPrecision(2));
                    it = Number((it * this.LCV).toPrecision(2));
                    physical = Number((physical * this.LCV).toPrecision(2));

                    this.overallRadarChartDataSets.push(
                        {
                            label: "Overall Vulnerability",
                            data: [human, it, physical]
                        }
                    );
                } else {
                    const area: VulnerabilityAreaMgm = this.vulnerabilityAreasMap.get(key);

                    if (area) {
                        this.dataSetByAreaMap.set(key,
                            {
                                label: area.name,
                                data: [human, it, physical]
                            }
                        );

                        this.radarChartDataSets.push(this.dataSetByAreaMap.get(area.id));
                    }
                }
            });

            // Sort the VulnerabilityAreas by the Total % value
            this.vulnerabilityAreas = this.vulnerabilityAreas.sort((a, b) => {
                let order = 0;

                if (this.data.has(a.id) && this.data.has(b.id)) {
                    if (this.data.get(a.id).has(ContainerType.INTANGIBLE) && this.data.get(b.id).has(ContainerType.INTANGIBLE)) {
                        order = this.data.get(b.id).get(ContainerType.INTANGIBLE) - this.data.get(a.id).get(ContainerType.INTANGIBLE);
                    }
                }

                return order;
            });
        }
    }

    private fetchDataSet() {
        if (this.vulnerabilityAssessment) {
            this.vulnerabilityRadarService.getVulnerabilityRadar(this.vulnerabilityAssessment.id)
                .toPromise()
                .then((response: HttpResponse<Map<number, Map<ContainerType, number>>>) => {
                    this.data = response.body;

                    this.buildDataSet();
                });
        }
    }

    /*public toggleChange(area: VulnerabilityAreaMgm, change: MatSlideToggleChange) {
        this.vulnerabilityAreasToggleMap.set(area.id, change.checked);

        // Update the DataSet
        this.radarChartDataSets = [];

        if (this.changeDetector && !(this.changeDetector as ViewRef).destroyed) {
            this.changeDetector.detectChanges();
        }

        //:::::::::::::::::::::::::::::::::::::::::::::::::::AreaID
        this.dataSetByAreaMap.forEach((value: ChartDataSets, key: number) => {
            if (this.vulnerabilityAreasToggleMap.get(key)) {
                this.radarChartDataSets.push(value);
            }
        });

        if (this.changeDetector && !(this.changeDetector as ViewRef).destroyed) {
            this.changeDetector.detectChanges();
        }
    }*/

    ngOnDestroy(): void {
        this.changeDetector.detach();

        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((subscription: Subscription) => {
                if (subscription) {
                    subscription.unsubscribe();
                }
            });
        }
    }
}
